---
title: 软通智算
date: 2024-12-25 20:25:54
tags: interview
---

项目面
time: 2024.12.18

# 筋斗云

## 1. 项目情景介绍

简要介绍项目的背景、目标、使用技术栈以及核心功能。


#### 为什么项目中同时涉及到了Gin和Hertz两个框架？使用到了Hertz中的什么特性？

项目本身是使用Gin开发的，后来进行了一次重构。因为学习到了Hertz，就使用了Hertz尝试进行重构。使用到了其中的中间件。



#### 目前上线的话 上线使用的范围 服务中间件分配的状况

项目目前的使用范围是本校内，使用人数有100人左右。目前的话是有两个服务器，中间件存放在一个服务器上，也有的是使用云服务。业务侧服务则运行在另外一个服务器上。



#### wire的作用，干了什么事

wire本质上是一个代码生成器，是一个帮我们管理和创建各层次结构体对象的容器。我个人的理解是可以类比成java中的bean容器。通过wire简化了我们创建和装配容器的过程，我们只需要在wire.go中注册就可以，运行wire就会生成wire_gen.go。



#### grpc在项目中怎么用的？为什么使用grpc，有什么优点？

gRPC在本项目中的作用就是传输业务侧的状态信息给数据分析模块。因为gRPC结合protobuf突出一个快和轻量级。而拉取状态信息的情境下，拉取的时机比较频繁，并且次数较多。所以使用gRPC就可以进一步放大它的这一个特点。



#### 服务发现模块是怎么实现的？整体架构？etcd-watch

是通过etcd实现的。etcd是一个强一致性的键值对存储，其中存储的是每个指标的信息。借助watch机制可以监听状态信息的变化，并及时更新到etcd中。当我的代理服务器需要获取最优服务列表的时候，会从etcd中获取信息。并且将获取到的状态信息进行计算，判断出最佳的服务并返回。



#### 评判状态优劣时包含的指标有？如何评判服务发现得到的服务列表的状态优劣？具体的评判算法？

通过获取到的各个指标，例如说是服务平均的耗时，每个服务的请求数。服务的CPU，内存等硬件资源。然后我们将各个时刻获取到的这些状态信息分别存储在结构体当中，并且存放在滑动窗口中。滑动窗口默认维护的是前5s的状态信息。拿出来计算的时候，会将这些信息根据对应的时间刻度乘以权重。这个权重的话是基于与目前的时间差值决定的，差值越大，权重值越小。换句话说，就是那时候的状态指标，对当前时刻的状态推测的置信度，比较低，所以将他的权重调小。最后再根据这个加权平均的值排序后，截取最优几项进行返回。



#### 是否有实际尝试过？

自己在程序部署的几个服务器上有尝试过，有一定的效果。



#### 服务注册怎么实现？配置文件注册？动态注册？（利用etcd-watch结合动态ip分配实现自动初始化）

目前是通过配置文件进行注册，在服务注册模块，将这几个服务都注册到其中。有一个动态分配的思路是，服务在初始化的时候随机动态分配IP和PORT，同步将它put到etcd中。然后利用etcd-watch机制监听对应的前缀，之后就可以实现，同步更新它的状态信息。这个也是我实现配置中心的一个思路。



#### 如何判断服务是否存活？

目前的状态信息是通过gRPC获取，gRPC获取信息的时候，假如能正常获取到状态信息，就代表着这个服务现在是运行中的，还没有宕机。假如服务宕机，gRPC就获取不到信息了。此时会进行几次重试，如果在几次重试之后都获取不到服务状态信息的话，就可以认为这个服务是宕机了的。在实现中，假如获取不到状态信息，就不会put到etcd中。



#### 为什么用到lua？怎么用的？

项目中用到lua有多个情景 主要的作用是结合Redis使用和实现Nginx配置热更新

1. 结合Redis实现了桶限流，通过Redis中的hash类型，我基于用户的颗粒度，为每个用户涉及了一个hashmap，其中有两个key，一个是当前的令牌数量，还有一个是上次读取时的时间。结合这两个值，在我调用接口的时候。我就可以哦通过我实现的这一个限流中间件，判断出上次登录的事件，并根据这个事件经计算出应该补充多少令牌。计算出需要补充的令牌之后，在判断当前的请求是否合法，是否应该被限流拦截下来。
2. 结合Redis-Zset实现Lru。通过将时间戳作为当前的分数，然后所有值将通过分数进行排序。当元素已满并且需要添加元素的时候，我只需要再加入的时候，淘汰掉分数最小的节点。就可以了。
3. 通过Nginx和OpenResty实现Nginx中最优列表的路由。Nginx本身的主要功能是体现了反向代理等，但是它除此之外的功能并不完善。于是就通过了OpenResty来发起一个请求，它会向我的Ipconfig模块发起一个http请求。这个请求会返回一个当前的最优服务列表。当拿到这个服务列表的时候，OpenResty会将它的更新到Nginx的共享缓存当中。而我的Nginx在涉及反向路由的时候只需要，从缓存中拿到这个值，就可以前往当前最优的服务了。而这里所说到的OpenResty所作的操作本质上只有执行了一个lua脚本。我所说到的关于发起请求，返回列表这些操作全都是在lua脚本中规定的。


### 调用的API与应对被墙问题

如果调用的是外部API（例如OpenAI），如何应对被墙等问题，确保服务可用。

## 14. MySQL事务的理解与应用

对MySQL事务的基本理解，如何实现高并发事务。
讨论自己编写SQL以应对大范围并发事务的经验。

---

# 消息推送平台

## 1. 业务场景介绍

- 介绍消息推送平台的业务场景和具体需求。
